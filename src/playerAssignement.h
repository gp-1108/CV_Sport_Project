/**
* @file playerAssignement.h
* @author Enrico D'Alberton ID number: 2093708
* @date ---
* @version 1.0
*/

#ifndef PLAYERASSIGNEMENT_H
#define PLAYERASSIGNEMENT_H

#include <opencv2/opencv.hpp>

/**
 * @brief computes the silhouette coefficient of the clustering. In this case the points are in 3D space (BGR)
 * @param clusters: vector containing the points organized in clusters 
 * @param match: vector containing all the points not organized
 * @param k: number of clusters
 * @return the silhouette coefficient of the clustering
*/
float silhouette(std::vector<std::tuple<int, int, int>> match, std::vector<std::vector<std::tuple<int, int, int>>> clusters, int k);

/**
 * @brief computes the silhouette coefficient of the clustering. In this case the points are in 2D space (RG or GB)
 * @param clusters: vector containing the points organized in clusters 
 * @param match: vector containing all the points not organized
 * @param k: number of clusters
 * @return the silhouette coefficient of the clustering
*/
float silhouette(std::vector<std::tuple<int, int>> match, std::vector<std::vector<std::tuple<int, int>>> clusters, int k);

/**
 * @brief k_means clustering algorithm. In this case the points are in 3D space (BGR)
 * @param match: vector containing all the points to be clustered
 * @param k: number of clusters
 * @return a vector containing the clusters
*/
std::vector<std::vector<std::tuple<int, int, int>>> k_means(std::vector<std::tuple<int, int, int>> match, int k);

/**
 * @brief k_means clustering algorithm. In this case the points are in 2D space (RG or GB)
 * @param match: vector containing all the points to be clustered
 * @param k: number of clusters
 * @return a vector containing the clusters
*/
std::vector<std::vector<std::tuple<int,int>>> k_means(std::vector<std::tuple<int,int>> match, int k);

/**
 * @brief find the maximum float value between three values. In this case the values are three different silhouettes coefficients corresponding to three different clusterings
 * @param a: first value
 * @param b: second value
 * @param c: third value
 * @return the maximum value
*/
float findMax(float a, float b, float c);

/**
 * @brief this function takes the mask generated by the NN and the original image, then it returns a vector containing the bounding boxes, the player colored mask and the uchar value of the player used in the binary mask
 * @param original_image: reference of the Mat object containing the original image
 * @param mask: reference of the Mat object containing the mask generated by the NN
 * @param players: vector containing the bounding boxes, the player colored mask and the uchar value of the player used in the binary. This vector will be filled by the function
*/
void localizePlayers(const cv::Mat& original_image, const cv::Mat& mask, std::vector<std::tuple<cv::Rect, cv::Mat, int>>& players);

/**
 * @brief this function is a utility function used to parse the clusters, formed by 3D points (BGR), and assign correctly each player to a team
 * @param clusters: vector containing the clusters
 * @param match: vector containing all the points not organized in clusters
 * @param team_membership: vector containing the team membership of each player (teamA or teamB). This vector will be filled by the function.
*/
void parseClusters(std::vector<std::vector<std::tuple<int, int, int>>> clusters, std::vector<std::tuple<int, int, int>> match, std::vector<int>& team_membership);

/**
 * @brief this function is a utility function used to parse the clusters, formed by 2D points (RG or GB), and assign correctly each player to a team
 * @param clusters: vector containing the clusters
 * @param match: vector containing all the points not organized in clusters
 * @param team_membership: vector containing the team membership of each player (teamA or teamB). This vector will be filled by the function.
*/
void parseClusters(std::vector<std::vector<std::tuple<int, int>>> clusters, std::vector<std::tuple<int, int>> match, std::vector<int>& team_membership);

/**
 * @brief this function saves the output of the algorithm in the output folder. It generates a binary mask, a colored mask and a text file containing the bounding box details and the team membership of each player
 * @param output_folder_path: string containing the path of the folder where the output files will be saved
 * @param file_name: string containing the name of the image that has been processed
 * @param RGB_mask: reference of the Mat object containing the colored mask of the players
 * @param BN_mask: reference of the Mat object containing the binary mask of the players
 * @param players: vector containing the bounding boxes, the player colored mask and the uchar value of the player used in the binary mask
 * @param team_membership: vector containing the team membership of each player (teamA or teamB)
*/
void saveOutput(const std::string& output_folder_path, const std::string& file_name, const cv::Mat& RGB_mask, const cv::Mat& BN_mask, const std::vector<std::tuple<cv::Rect, cv::Mat, int>>& players, const std::vector<int>& team_membership);

/**
 * @brief this function execute the entire player assignement algorithm. All the other functions are called inside this one by cascade
 * @param output_folder_path: string containing the path of the folder where the output files will be saved
 * @param file_name: string containing the name of the image that has been processed
 * @param original_image: reference of the Mat object containing the original image
 * @param mask: reference of the Mat object containing the mask generated by the NN
 * @param field_mask: reference of the Mat object containing the mask of the field
*/
void assignToTeams(const std::string& output_folder_path, std::string file_name, cv::Mat& original_image, cv::Mat& mask, cv::Mat& field_mask);

#endif