/**
* @file playerAssignement.h
* @author Enrico D'Alberton ID number: 2093708
*/

#ifndef PLAYERASSIGNEMENT_H
#define PLAYERASSIGNEMENT_H

#include <opencv2/opencv.hpp>

/**
 * @brief computes the silhouette coefficient of the clustering. In this case the points are in 3D space (BGR)
 * @param clusters: vector containing the points organized in clusters 
 * @param match: vector containing all the points not organized
 * @param k: number of clusters
 * @return the silhouette coefficient of the clustering
*/
float silhouette(std::vector<std::tuple<int, int, int>> match, std::vector<std::vector<std::tuple<int, int, int>>> clusters, int k);

/**
 * @brief computes the silhouette coefficient of the clustering. In this case the points are in 2D space (RG or GB)
 * @param clusters: vector containing the points organized in clusters 
 * @param match: vector containing all the points not organized
 * @param k: number of clusters
 * @return the silhouette coefficient of the clustering
*/
float silhouette(std::vector<std::tuple<int, int>> match, std::vector<std::vector<std::tuple<int, int>>> clusters, int k);

/**
 * @brief k_means clustering algorithm. In this case the points are in 3D space (BGR)
 * @param match: vector containing all the points to be clustered
 * @param k: number of clusters
 * @return a vector containing the clusters
*/
std::vector<std::vector<std::tuple<int, int, int>>> k_means(std::vector<std::tuple<int, int, int>> match, int k);

/**
 * @brief k_means clustering algorithm. In this case the points are in 2D space (RG or GB)
 * @param match: vector containing all the points to be clustered
 * @param k: number of clusters
 * @return a vector containing the clusters
*/
std::vector<std::vector<std::tuple<int,int>>> k_means(std::vector<std::tuple<int,int>> match, int k);

/**
 * @brief find the maximum float value between three values. In this case the values are three different silhouettes coefficients corresponding to three different clusterings
 * @param a: first value
 * @param b: second value
 * @param c: third value
 * @return the maximum value
*/
float findMax(float a, float b, float c);

/**
 * @brief this function takes the mask generated by the NN and the original image, then it returns a vector containing the bounding boxes, the player colored mask and the uchar value of the player used in the binary mask
 * @param original_image: reference of the Mat object containing the original image
 * @param mask: reference of the Mat object containing the mask generated by the NN
 * @param players: vector containing the bounding boxes, the player colored mask and the uchar value of the player used in the binary. This vector will be filled by the function
*/
void localizePlayers(const cv::Mat& original_image, const cv::Mat& mask, std::vector<std::tuple<cv::Rect, cv::Mat, int>>& players);

/**
 * @brief this function is a utility function used to parse the clusters, formed by 3D points (BGR), and assign correctly each player to a team
 * @param clusters: vector containing the clusters
 * @param match: vector containing all the points not organized in clusters
 * @param team_membership: vector containing the team membership of each player (teamA or teamB). This vector will be filled by the function.
 * @param confidence: vector containing the confidence of each player
 * @param centroids: vector containing the 3D values of the centroids of each cluster
 * @param max_distance_from_centroids: vector containing the maximum distance of each cluster from its centroid
*/
void parseClusters(std::vector<std::vector<std::tuple<int, int, int>>> clusters, std::vector<std::tuple<int, int, int>> match, std::vector<int>& team_membership, std::vector<float>& confidence, const std::vector<std::tuple<int, int, int>>& centroids, const std::vector<int>& max_distance_from_centroids);

/**
 * @brief this function is a utility function used to parse the clusters, formed by 2D points (RG or GB), and assign correctly each player to a team
 * @param clusters: vector containing the clusters
 * @param match: vector containing all the points not organized in clusters
 * @param team_membership: vector containing the team membership of each player (teamA or teamB). This vector will be filled by the function.
 * @param confidence: vector containing the confidence of each player
 * @param centroids: vector containing the 2D values of the centroids of each cluster
 * @param max_distance_from_centroids: vector containing the maximum distance of each cluster from its centroid
*/
void parseClusters(std::vector<std::vector<std::tuple<int, int>>> clusters, std::vector<std::tuple<int, int>> match, std::vector<int>& team_membership, std::vector<float>& confidence, const std::vector<std::tuple<int, int>>& centroids, const std::vector<int>& max_distance_from_centroids);

/**
 * @brief this function saves the output of the algorithm in the output folder. It generates a binary mask, a colored mask and a text file containing the bounding box details and the team membership of each player
 * @param output_folder_path: string containing the path of the folder where the output files will be saved
 * @param file_name: string containing the name of the image that has been processed
 * @param RGB_mask: reference of the Mat object containing the colored mask of the players
 * @param BN_mask: reference of the Mat object containing the binary mask of the players
 * @param players_features: vector containing [x, y, width, height, team membership, confidence of each player]. This vector will be used to produce the text file
*/
void saveOutput(const std::string& output_folder_path, const std::string& file_name, const cv::Mat& RGB_mask, const cv::Mat& BN_mask, const std::vector<std::tuple<int, int, int, int, int, float>>& players_features);

/**
 * @brief this function computes the centroids of the clusters and the maximum distance of each cluster from its centroid. In this case the points are in 3D space (BGR)
 * @param clusters: vector containing the clusters and the points inside them
 * @param centroids: vector containing the 3D values of the centroids of each cluster. This vector will be filled by the function
 * @param max_distance_from_centroids: vector containing the maximum distance of each cluster from its centroid. This vector will be filled by the function
*/
void computeCentroids(const std::vector<std::vector<std::tuple<int, int, int>>>& clusters, std::vector<std::tuple<int,int,int>>& centroids, std::vector<int>& max_distance_from_centroids);

/**
 * @brief this function computes the centroids of the clusters and the maximum distance of each cluster from its centroid. In this case the points are in 2D space (RG or GB)
 * @param clusters: vector containing the clusters and the points inside them
 * @param centroids: vector containing the 2D values of the centroids of each cluster. This vector will be filled by the function
 * @param max_distance_from_centroids: vector containing the maximum distance of each cluster from its centroid. This vector will be filled by the function
*/
void computeCentroids(const std::vector<std::vector<std::tuple<int, int>>>& clusters, std::vector<std::tuple<int,int,int>>& centroids, std::vector<int>& max_distance_from_centroids);

/**
 * @brief this function execute the entire player assignement algorithm. All the other functions are called inside this one by cascade
 * @param output_folder_path: string containing the path of the folder where the output files will be saved
 * @param file_name: string containing the name of the image that has been processed
 * @param original_image: reference of the Mat object containing the original image
 * @param mask: reference of the Mat object containing the mask generated by the NN
 * @param field_mask: reference of the Mat object containing the mask of the field
*/
void assignToTeams(const std::string& output_folder_path, std::string file_name, cv::Mat& original_image, cv::Mat& mask, cv::Mat& field_mask);

#endif